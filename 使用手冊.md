# Sunneo/libs 使用手冊 (User Manual)

## 目錄 (Table of Contents)

1. [快速開始](#快速開始-quick-start)
2. [環境設定](#環境設定-environment-setup)
3. [建置指南](#建置指南-build-guide)
4. [模組使用教學](#模組使用教學)
5. [常見問題](#常見問題-faq)
6. [最佳實踐](#最佳實踐-best-practices)
7. [疑難排解](#疑難排解-troubleshooting)

---

## 快速開始 (Quick Start)

### 5 分鐘快速上手

```bash
# 1. 克隆儲存庫
git clone https://github.com/sunneo/libs.git
cd libs

# 2. 建置 List 模組
cd List
make

# 3. 執行測試
make test

# 4. 使用函式庫
# 在你的專案中包含標頭檔和連結靜態庫
gcc -I./include your_program.c -L./bin -lList -o your_program
```

---

## 環境設定 (Environment Setup)

### 系統需求

- **作業系統**: Linux, Unix, macOS, Windows (with MinGW/Cygwin)
- **編譯器**: GCC 4.x 或更新版本
- **建置工具**: Make
- **可選**: pthread (用於多執行緒版本)

### 安裝編譯工具

**Ubuntu/Debian:**
```bash
sudo apt-get update
sudo apt-get install build-essential gcc make
```

**Fedora/CentOS:**
```bash
sudo yum groupinstall "Development Tools"
```

**macOS:**
```bash
xcode-select --install
```

**Windows (MinGW):**
```bash
# 下載並安裝 MinGW 或 MSYS2
# http://www.mingw.org/
```

---

## 建置指南 (Build Guide)

### 建置單一模組

每個模組都有獨立的 Makefile，可以單獨編譯：

```bash
cd <module_name>
make          # 建置靜態函式庫
make test     # 建置並執行測試
make clean    # 清除編譯產物
make remake   # 重新建置
```

### 建置所有模組

建議使用腳本批次建置：

```bash
#!/bin/bash
# build_all.sh

MODULES="List Vector Stack Queue HashMap BinTree RBTree"

for module in $MODULES; do
    echo "Building $module..."
    cd $module
    make
    cd ..
done
```

### 整合到你的專案

**方法 1: 靜態連結**
```bash
gcc -I/path/to/libs/List/include \
    your_code.c \
    -L/path/to/libs/List/bin \
    -lList \
    -o your_program
```

**方法 2: 直接包含原始碼**
```bash
gcc -I/path/to/libs/List/include \
    your_code.c \
    /path/to/libs/List/src/list.c \
    /path/to/libs/List/src/listiter.c \
    -o your_program
```

---

## 模組使用教學

### 1. List (鏈結串列)

#### 基本操作

```c
#include "list.h"
#include <stdio.h>
#include <string.h>

// 比較函式（用於搜尋）
int int_compare(const void* a, const void* b) {
    int ia = *(int*)a;
    int ib = *(int*)b;
    return (ia == ib);
}

int main() {
    // 建立串列（元素大小, 比較函式）
    List* list = list_create(sizeof(int), int_compare);
    
    // 新增元素
    int values[] = {10, 20, 30, 40, 50};
    for (int i = 0; i < 5; i++) {
        list_push_back(list, &values[i]);
    }
    
    // 取得大小
    printf("List size: %u\n", list_size(list));
    
    // 存取元素
    int* front = (int*)list_front(list);
    int* back = (int*)list_back(list);
    printf("Front: %d, Back: %d\n", *front, *back);
    
    // 搜尋元素
    int search_val = 30;
    int* found = (int*)list_find_first(list, &search_val);
    if (found) {
        printf("Found: %d\n", *found);
    }
    
    // 刪除元素
    list_erase(list, &values[2]);
    
    // 釋放資源
    list_delete(list);
    
    return 0;
}
```

#### 使用迭代器遍歷

```c
#include "list.h"
#include <stdio.h>

int main() {
    List* list = list_create(sizeof(int), NULL);
    
    // 新增資料
    for (int i = 1; i <= 5; i++) {
        list_push_back(list, &i);
    }
    
    // 使用迭代器遍歷
    ListIter iter = list_get_iter(list);
    while (list_iter_hasNext(iter)) {
        int* data = (int*)list_iter_next(iter);
        printf("%d ", *data);
    }
    printf("\n");
    
    // 釋放迭代器
    list_iter_delete(iter);
    list_delete(list);
    
    return 0;
}
```

#### 自訂資料結構範例

```c
#include "list.h"
#include <stdio.h>
#include <string.h>

typedef struct {
    int id;
    char name[32];
    double score;
} Student;

int student_compare(const void* a, const void* b) {
    Student* sa = (Student*)a;
    Student* sb = (Student*)b;
    return (sa->id == sb->id);
}

int main() {
    List* students = list_create(sizeof(Student), student_compare);
    
    // 新增學生
    Student s1 = {1, "Alice", 95.5};
    Student s2 = {2, "Bob", 87.3};
    Student s3 = {3, "Carol", 92.1};
    
    list_push_back(students, &s1);
    list_push_back(students, &s2);
    list_push_back(students, &s3);
    
    // 遍歷並顯示
    ListIter iter = list_get_iter(students);
    while (list_iter_hasNext(iter)) {
        Student* s = (Student*)list_iter_next(iter);
        printf("ID: %d, Name: %s, Score: %.1f\n", 
               s->id, s->name, s->score);
    }
    
    list_iter_delete(iter);
    list_delete(students);
    
    return 0;
}
```

---

### 2. Vector (動態陣列)

#### 基本操作

```c
#include "vector.h"
#include <stdio.h>

int main() {
    // 建立 vector（元素大小）
    Vector* vec = vector_create(sizeof(int));
    
    // 新增元素
    for (int i = 0; i < 10; i++) {
        vector_push_back(vec, &i);
    }
    
    // 隨機存取
    for (int i = 0; i < vector_size(vec); i++) {
        int* val = (int*)vector_at(vec, i);
        printf("%d ", *val);
    }
    printf("\n");
    
    // 插入元素
    int new_val = 99;
    vector_insert(vec, 5, &new_val);
    
    // 刪除元素
    vector_erase(vec, 3);
    
    // 釋放資源
    vector_delete(vec);
    
    return 0;
}
```

#### 儲存指標而非值

```c
#include "vector.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    // elesize = 0 表示儲存指標
    Vector* vec = vector_create(0);
    
    // 分配字串並儲存指標
    char* str1 = strdup("Hello");
    char* str2 = strdup("World");
    char* str3 = strdup("!");
    
    vector_push_back(vec, str1);
    vector_push_back(vec, str2);
    vector_push_back(vec, str3);
    
    // 存取指標
    for (int i = 0; i < vector_size(vec); i++) {
        char* str = (char*)vector_at(vec, i);
        printf("%s ", str);
    }
    printf("\n");
    
    // 釋放字串記憶體
    for (int i = 0; i < vector_size(vec); i++) {
        free((char*)vector_at(vec, i));
    }
    
    vector_delete(vec);
    
    return 0;
}
```

#### 使用自訂析構函式

```c
#include "vector.h"
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char* data;
    int size;
} MyObject;

void my_object_destroy(void* obj) {
    MyObject* myobj = (MyObject*)obj;
    if (myobj->data) {
        free(myobj->data);
        myobj->data = NULL;
    }
    printf("Object destroyed\n");
}

int main() {
    Vector* vec = vector_create(sizeof(MyObject));
    
    // 設定析構函式
    vector_setPopFunction(vec, my_object_destroy);
    
    // 新增物件
    MyObject obj1 = {strdup("test1"), 5};
    MyObject obj2 = {strdup("test2"), 5};
    
    vector_push_back(vec, &obj1);
    vector_push_back(vec, &obj2);
    
    // 當 pop_back 或 delete 時會自動呼叫析構函式
    vector_pop_back(vec);  // 會呼叫 my_object_destroy
    vector_delete(vec);    // 會對剩餘元素呼叫 my_object_destroy
    
    return 0;
}
```

---

### 3. HashMap (雜湊映射表)

#### 基本操作

```c
#include "hashmap.h"
#include <stdio.h>
#include <string.h>

// 字串雜湊函式
int string_hash(const void* key) {
    const char* str = (const char*)key;
    unsigned int hash = 0;
    while (*str) {
        hash = hash * 31 + (*str++);
    }
    return hash;
}

// 字串比較函式
int string_equal(const void* a, const void* b) {
    return strcmp((const char*)a, (const char*)b) == 0;
}

int main() {
    // 建立 HashMap
    struct HashMap* map = hashmap_new(string_hash, string_equal);
    
    // 插入 key-value 對
    hashmap_put(map, "name", "Alice");
    hashmap_put(map, "age", "25");
    hashmap_put(map, "city", "Taipei");
    
    // 查詢
    char* name = (char*)hashmap_get(map, "name");
    printf("Name: %s\n", name);
    
    // 檢查是否包含 key
    if (hashmap_contains_key(map, "age")) {
        printf("Age exists\n");
    }
    
    // 刪除
    hashmap_remove(map, "city");
    
    // 大小
    printf("Size: %d\n", hashmap_size(map));
    
    // 釋放資源
    hashmap_delete(map);
    
    return 0;
}
```

#### 整數鍵值範例

```c
#include "hashmap.h"
#include <stdio.h>

int int_hash(const void* key) {
    return *(int*)key;
}

int int_equal(const void* a, const void* b) {
    return *(int*)a == *(int*)b;
}

int main() {
    struct HashMap* map = hashmap_new(int_hash, int_equal);
    
    // 注意：key 和 value 都需要是持久的記憶體位址
    static int keys[] = {1, 2, 3, 4, 5};
    static char* values[] = {"one", "two", "three", "four", "five"};
    
    for (int i = 0; i < 5; i++) {
        hashmap_put(map, &keys[i], values[i]);
    }
    
    int search_key = 3;
    char* result = (char*)hashmap_get(map, &search_key);
    printf("Key 3 -> %s\n", result);
    
    hashmap_delete(map);
    
    return 0;
}
```

---

### 4. RBTree (紅黑樹)

#### 基本操作

```c
#include "rbtree.h"
#include <stdio.h>

int int_compare(const void* a, const void* b) {
    int ia = *(int*)a;
    int ib = *(int*)b;
    return (ia > ib) - (ia < ib);  // 返回 -1, 0, 1
}

void print_value(void* data) {
    int* val = (int*)data;
    printf("%d ", *val);
}

int main() {
    // 建立紅黑樹（資料大小, 鍵大小, 比較函式）
    RBTree* tree = rbtree_create(sizeof(int), sizeof(int), int_compare);
    
    // 插入資料
    int keys[] = {50, 30, 70, 20, 40, 60, 80};
    for (int i = 0; i < 7; i++) {
        rbtree_insert(tree, &keys[i], &keys[i]);
    }
    
    // 搜尋
    int search_key = 40;
    int* found = (int*)rbtree_search(tree, &search_key);
    if (found) {
        printf("Found: %d\n", *found);
    }
    
    // 取得最小/最大值
    int* min_val = (int*)rbtree_min(tree);
    int* max_val = (int*)rbtree_max(tree);
    printf("Min: %d, Max: %d\n", *min_val, *max_val);
    
    // 中序遍歷（有序輸出）
    printf("Inorder: ");
    rbtree_inorder(tree, print_value);
    printf("\n");
    
    // 刪除節點
    rbtree_erase(tree, &search_key);
    
    // 大小
    printf("Size: %zu\n", rbtree_size(tree));
    
    // 釋放資源
    rbtree_delete(tree);
    
    return 0;
}
```

#### 遍歷方式

```c
#include "rbtree.h"
#include <stdio.h>

void print_value(void* data) {
    printf("%d ", *(int*)data);
}

int main() {
    RBTree* tree = rbtree_create(sizeof(int), sizeof(int), int_compare);
    
    // 插入資料...
    int values[] = {5, 3, 7, 2, 4, 6, 8};
    for (int i = 0; i < 7; i++) {
        rbtree_insert(tree, &values[i], &values[i]);
    }
    
    // 前序遍歷
    printf("Preorder:  ");
    rbtree_preorder(tree, print_value);
    printf("\n");
    
    // 中序遍歷（有序）
    printf("Inorder:   ");
    rbtree_inorder(tree, print_value);
    printf("\n");
    
    // 後序遍歷
    printf("Postorder: ");
    rbtree_postorder(tree, print_value);
    printf("\n");
    
    // 廣度優先遍歷
    printf("BFS:       ");
    rbtree_bfs_foreach(tree, print_value);
    printf("\n");
    
    // 深度優先遍歷
    printf("DFS:       ");
    rbtree_dfs_foreach(tree, print_value);
    printf("\n");
    
    rbtree_delete(tree);
    
    return 0;
}
```

---

### 5. Stack (堆疊)

```c
#include "stack.h"
#include <stdio.h>

int main() {
    Stack* stack = stack_create(sizeof(int));
    
    // Push 元素
    for (int i = 1; i <= 5; i++) {
        stack_push(stack, &i);
    }
    
    // 查看 top 元素
    int* top = (int*)stack_top(stack);
    printf("Top: %d\n", *top);
    
    // Pop 元素
    while (!stack_empty(stack)) {
        int* val = (int*)stack_top(stack);
        printf("%d ", *val);
        stack_pop(stack);
    }
    printf("\n");
    
    stack_delete(stack);
    
    return 0;
}
```

---

### 6. Queue (佇列)

```c
#include "queue.h"
#include <stdio.h>

int main() {
    Queue* queue = queue_create(sizeof(int));
    
    // Enqueue 元素
    for (int i = 1; i <= 5; i++) {
        queue_enqueue(queue, &i);
    }
    
    // 查看 front 元素
    int* front = (int*)queue_front(queue);
    printf("Front: %d\n", *front);
    
    // Dequeue 元素
    while (!queue_empty(queue)) {
        int* val = (int*)queue_front(queue);
        printf("%d ", *val);
        queue_dequeue(queue);
    }
    printf("\n");
    
    queue_delete(queue);
    
    return 0;
}
```

---

### 7. String (動態字串)

```c
#include "cstring.h"
#include <stdio.h>

int main() {
    // 建立字串
    String* str = string_create("Hello");
    
    // 連接字串
    string_append_cstr(str, " World");
    string_append_char(str, '!');
    
    // 格式化附加
    string_append_format(str, " Count: %d", 42);
    
    // 取得 C 字串
    printf("%s\n", string_buffer(str));
    
    // 長度
    printf("Length: %u\n", string_length(str));
    
    // 搜尋
    char* pos = string_findfirst(str, 0, "World");
    if (pos) {
        printf("Found 'World' at position: %ld\n", pos - string_buffer(str));
    }
    
    // 字元索引
    int idx = string_indexof_char(str, 0, '!');
    printf("'!' at index: %d\n", idx);
    
    // 複製
    String* str2 = string_create("");
    string_copy(str2, str);
    
    // 清空
    string_clear(str);
    
    // 釋放資源
    string_delete(str);
    string_delete(str2);
    
    return 0;
}
```

---

### 8. BMP (點陣圖處理)

#### 建立與繪圖

```c
#include "bmp.h"
#include <stdio.h>

int main() {
    // 建立 BMP（寬, 高, 背景色）
    BMP* bmp = bmp_create(800, 600, 0xFFFFFF);  // 白色背景
    
    // 繪製點
    bmp_point(bmp, 100, 100, 0xFF0000);  // 紅點
    
    // 繪製線
    bmp_line(bmp, 50, 50, 200, 200, 0x0000FF);  // 藍線
    
    // 繪製矩形
    bmp_rect(bmp, 300, 300, 100, 80, 0x00FF00);  // 綠矩形
    
    // 繪製圓形
    bmp_circle(bmp, 400, 300, 50, 1.0, 1.0, 0xFF00FF);  // 洋紅圓
    
    // 填充
    bmp_paint(bmp, 350, 350, 0xFFFF00);  // 黃色填充
    
    // 儲存檔案
    bmp_write(bmp, "output.bmp");
    
    // 釋放資源
    bmp_delete(bmp);
    
    printf("BMP file created: output.bmp\n");
    
    return 0;
}
```

#### 讀取與修改

```c
#include "bmp.h"
#include <stdio.h>

int main() {
    // 從檔案載入
    BMP* bmp = bmp_create_from_file("input.bmp");
    if (!bmp) {
        printf("Failed to load BMP\n");
        return 1;
    }
    
    // 取得像素顏色
    ulong color = bmp_pos_clr(bmp, 100, 100);
    printf("Color at (100,100): 0x%06lX\n", color);
    
    // 修改像素
    bmp_point(bmp, 100, 100, 0xFF0000);
    
    // 繪製到現有圖像
    bmp_line(bmp, 0, 0, 199, 199, 0x000000);
    
    // 儲存修改
    bmp_write(bmp, "modified.bmp");
    
    bmp_delete(bmp);
    
    return 0;
}
```

---

### 9. Coroutine (協程)

#### ucontext 版本

```c
#include "coroutine.h"
#include <stdio.h>

void fibonacci(void* parm) {
    int a = 0, b = 1;
    
    while (1) {
        fiber_yieldi(a);
        
        int temp = a + b;
        a = b;
        b = temp;
    }
}

int main() {
    // 建立 fiber
    Fiber* fib = fiber_create(fibonacci, NULL);
    
    // 啟動 fiber
    fiber_start(fib);
    
    // 執行 10 次並取得結果
    for (int i = 0; i < 10; i++) {
        fiber_resume(fib);
        int value = fiber_get_yieldi(fib);
        printf("%d ", value);
    }
    printf("\n");
    
    // 檢查是否結束
    if (!fiber_terminated(fib)) {
        printf("Fiber is still running\n");
    }
    
    // 釋放資源
    fiber_delete(fib);
    
    return 0;
}
```

#### 生產者-消費者範例

```c
#include "coroutine.h"
#include <stdio.h>

void producer(void* parm) {
    for (int i = 1; i <= 5; i++) {
        printf("Producing: %d\n", i);
        fiber_yieldi(i);
    }
}

void consumer(void* parm) {
    Fiber* prod = (Fiber*)parm;
    
    while (!fiber_terminated(prod)) {
        fiber_resume(prod);
        if (!fiber_terminated(prod)) {
            int value = fiber_get_yieldi(prod);
            printf("Consuming: %d\n", value);
        }
    }
}

int main() {
    Fiber* prod = fiber_create(producer, NULL);
    fiber_start(prod);
    
    consumer(prod);
    
    fiber_delete(prod);
    
    return 0;
}
```

---

### 10. Socket (網路程式設計)

#### TCP Server

```c
#include "tcp_sck.h"
#include <stdio.h>
#include <string.h>

int main() {
    int server_sock, client_sock;
    struct sockaddr_in server_addr, client_addr;
    socklen_t client_len = sizeof(client_addr);
    char buffer[1024];
    
    // 建立 socket
    server_sock = socket(AF_INET, SOCK_STREAM, 0);
    
    // 設定位址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(8080);
    
    // 綁定
    bind(server_sock, (struct sockaddr*)&server_addr, sizeof(server_addr));
    
    // 監聽
    listen(server_sock, 5);
    printf("Server listening on port 8080...\n");
    
    // 接受連線
    client_sock = accept(server_sock, (struct sockaddr*)&client_addr, &client_len);
    printf("Client connected!\n");
    
    // 接收資料
    int n = recv(client_sock, buffer, sizeof(buffer)-1, 0);
    buffer[n] = '\0';
    printf("Received: %s\n", buffer);
    
    // 發送回應
    char* response = "Hello from server!";
    send(client_sock, response, strlen(response), 0);
    
    // 關閉
    close(client_sock);
    close(server_sock);
    
    return 0;
}
```

#### TCP Client

```c
#include "tcp_sck.h"
#include <stdio.h>
#include <string.h>

int main() {
    int sock;
    struct sockaddr_in server_addr;
    char buffer[1024];
    
    // 建立 socket
    sock = socket(AF_INET, SOCK_STREAM, 0);
    
    // 設定伺服器位址
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr("127.0.0.1");
    server_addr.sin_port = htons(8080);
    
    // 連線
    if (connect(sock, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        printf("Connection failed\n");
        return 1;
    }
    printf("Connected to server!\n");
    
    // 發送資料
    char* message = "Hello from client!";
    send(sock, message, strlen(message), 0);
    
    // 接收回應
    int n = recv(sock, buffer, sizeof(buffer)-1, 0);
    buffer[n] = '\0';
    printf("Received: %s\n", buffer);
    
    // 關閉
    close(sock);
    
    return 0;
}
```

---

### 11. Permutation (排列生成器)

```c
#include "permutation.h"
#include "iter.h"
#include <stdio.h>

int main() {
    int arr[] = {1, 2, 3, 4};
    int n = 4;
    
    // 建立排列生成器
    Permutation* perm = permutation_create(arr, n, sizeof(int));
    
    printf("All permutations of {1,2,3,4}:\n");
    
    int count = 0;
    // 遍歷所有排列
    while (permutation_has_next(perm)) {
        int* current = (int*)permutation_next(perm);
        
        printf("Permutation %d: ", ++count);
        for (int i = 0; i < n; i++) {
            printf("%d ", current[i]);
        }
        printf("\n");
    }
    
    printf("Total: %d permutations\n", count);
    
    permutation_delete(perm);
    
    return 0;
}
```

---

### 12. Powerset (冪集生成器)

```c
#include "powerset.h"
#include "iter.h"
#include <stdio.h>

int main() {
    int arr[] = {1, 2, 3};
    int n = 3;
    
    // 建立冪集生成器
    Powerset* ps = powerset_create(arr, n, sizeof(int));
    
    printf("All subsets of {1,2,3}:\n");
    
    int count = 0;
    // 遍歷所有子集
    while (powerset_has_next(ps)) {
        PowersetResult* subset = powerset_next(ps);
        
        printf("Subset %d: {", ++count);
        for (int i = 0; i < subset->size; i++) {
            int* val = (int*)((char*)subset->data + i * sizeof(int));
            printf("%d", *val);
            if (i < subset->size - 1) printf(", ");
        }
        printf("}\n");
    }
    
    printf("Total: %d subsets (including empty set)\n", count);
    
    powerset_delete(ps);
    
    return 0;
}
```

---

### 13. Macro (泛型巨集)

#### 使用 Macro Array

```c
#include "macro_array.h"
#include <stdio.h>

// 定義 int 類型的陣列
ArrayDefine(int)

int main() {
    // 宣告陣列
    int_Array* arr;
    ArrayDeclare(int);
    
    // 建立陣列
    ArrayCreate(arr);
    
    // 新增元素
    for (int i = 0; i < 10; i++) {
        ArrayPushBack(arr, i);
    }
    
    // 存取元素
    for (int i = 0; i < arr->size; i++) {
        printf("%d ", ArrayIndexOf(arr, i));
    }
    printf("\n");
    
    // 調整大小
    ArrayResize(arr, 20);
    
    // 銷毀陣列
    ArrayDestroy(arr);
    
    return 0;
}
```

#### 使用 Macro List

```c
#include "macro_list.h"
#include <stdio.h>

// 定義 double 類型的串列
ListDefine(double)

int main() {
    double_List* list;
    ListDeclare(double);
    
    // 建立串列
    ListCreate(list);
    
    // 新增元素
    ListPushBack(list, 3.14);
    ListPushBack(list, 2.71);
    ListPushBack(list, 1.41);
    ListPushFront(list, 0.57);
    
    // 大小
    printf("Size: %d\n", ListSize(list));
    
    // 遍歷
    ListForEach(list, element) {
        printf("%.2f ", element);
    }
    printf("\n");
    
    // 銷毀串列
    ListDestroy(list);
    
    return 0;
}
```

---

### 14. File Utilities (檔案工具)

```c
#include "fileutil.h"
#include <stdio.h>

void print_file(const char* filename) {
    printf("File: %s\n", filename);
}

int main() {
    const char* filepath = "test.txt";
    
    // 寫入檔案
    char* content = "Hello, World!\n";
    file_write(filepath, content, strlen(content));
    
    // 檢查檔案是否存在
    if (file_exists(filepath)) {
        printf("File exists\n");
    }
    
    // 取得檔案大小
    off_t size = file_size(filepath);
    printf("File size: %ld bytes\n", size);
    
    // 取得修改時間
    time_t mtime = file_mtime(filepath);
    printf("Modified: %s", ctime(&mtime));
    
    // 讀取檔案
    char buffer[1024];
    file_read(filepath, buffer, sizeof(buffer));
    printf("Content: %s", buffer);
    
    // 附加資料
    file_append(filepath, "More text\n", 10);
    
    // 列出目錄
    file_list(".", print_file, 0);  // 列出當前目錄所有檔案
    
    // 刪除檔案
    file_delete(filepath);
    
    return 0;
}
```

---

## 常見問題 (FAQ)

### Q1: 如何選擇適合的資料結構？

**A**: 根據你的需求：
- **需要快速隨機存取**: 使用 `Vector`
- **頻繁插入/刪除**: 使用 `List`
- **需要 LIFO**: 使用 `Stack`
- **需要 FIFO**: 使用 `Queue`
- **需要 Key-Value 查詢**: 使用 `HashMap`
- **需要有序資料**: 使用 `RBTree` 或 `B+ Tree`
- **需要優先級處理**: 使用 `Heap`

### Q2: 記憶體洩漏問題

**A**: 
- 所有 `xxx_create()` 都必須對應 `xxx_delete()`
- 如果儲存指標（elesize = 0），需要手動釋放指標指向的記憶體
- 使用 Valgrind 檢測記憶體洩漏：
  ```bash
  valgrind --leak-check=full ./your_program
  ```

### Q3: 執行緒安全性

**A**: 
- 預設情況下，所有資料結構都**不是執行緒安全的**
- 多執行緒環境需要自行加鎖：
  ```c
  pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
  
  pthread_mutex_lock(&lock);
  list_push_back(list, data);
  pthread_mutex_unlock(&lock);
  ```

### Q4: 如何儲存自訂結構？

**A**: 
```c
typedef struct {
    int id;
    char name[32];
} MyStruct;

// 建立時指定結構大小
List* list = list_create(sizeof(MyStruct), my_compare);

// 新增時傳遞位址
MyStruct data = {1, "test"};
list_push_back(list, &data);

// 取得時轉型
MyStruct* retrieved = (MyStruct*)list_front(list);
```

### Q5: HashMap 的 key 和 value 生命週期

**A**: 
- HashMap 只儲存指標，不複製內容
- Key 和 Value 必須在 HashMap 的整個生命週期內保持有效
- 建議：
  - 使用靜態陣列或 malloc 分配的記憶體
  - 不要使用區域變數或暫時變數

### Q6: 編譯錯誤處理

**A**: 
常見問題：
1. **找不到標頭檔**: 使用 `-I` 指定 include 路徑
2. **undefined reference**: 使用 `-L` 和 `-l` 連結函式庫
3. **版本不相容**: 確保使用 GCC 4.x 以上版本

### Q7: 如何除錯？

**A**: 
```bash
# 編譯時加入除錯資訊
gcc -g -I./include your_code.c -L./bin -lList -o your_program

# 使用 GDB
gdb ./your_program
(gdb) break main
(gdb) run
(gdb) step
(gdb) print variable_name
```

---

## 最佳實踐 (Best Practices)

### 1. 錯誤處理

```c
List* list = list_create(sizeof(int), int_compare);
if (!list) {
    fprintf(stderr, "Failed to create list\n");
    return -1;
}
```

### 2. 資源管理

```c
// 使用 goto 統一清理資源
int function() {
    List* list = list_create(sizeof(int), NULL);
    Vector* vec = vector_create(sizeof(int));
    int ret = 0;
    
    if (!list || !vec) {
        ret = -1;
        goto cleanup;
    }
    
    // 執行操作...
    
cleanup:
    if (list) list_delete(list);
    if (vec) vector_delete(vec);
    return ret;
}
```

### 3. 常數正確性

```c
// 對於只讀參數，傳遞 const 指標
void print_list(const List* list) {
    // ...
}
```

### 4. 避免不必要的複製

```c
// 好：儲存指標
Vector* vec = vector_create(0);  // elesize = 0
MyStruct* data = malloc(sizeof(MyStruct));
vector_push_back(vec, data);

// 差：大結構的複製
Vector* vec = vector_create(sizeof(LargeStruct));  // 每次都複製
```

### 5. 使用迭代器而非索引

```c
// 好：使用迭代器（List 效能較佳）
ListIter iter = list_get_iter(list);
while (list_iter_hasNext(iter)) {
    void* data = list_iter_next(iter);
    // 處理...
}
list_iter_delete(iter);

// 差：使用索引（List 需要遍歷）
for (int i = 0; i < list_size(list); i++) {
    void* data = list_at(list, i);  // O(n) 每次
}
```

---

## 疑難排解 (Troubleshooting)

### 問題 1: Segmentation Fault

**可能原因**:
- 存取已釋放的記憶體
- 陣列越界
- NULL 指標解參考

**解決方法**:
```bash
# 使用 GDB 除錯
gdb ./program
(gdb) run
# 當 crash 時
(gdb) backtrace
(gdb) frame 0
(gdb) print variable
```

### 問題 2: 記憶體洩漏

**檢測**:
```bash
valgrind --leak-check=full --show-leak-kinds=all ./program
```

**修正**:
- 確保所有 `create` 都有對應的 `delete`
- 釋放 elesize=0 時儲存的指標

### 問題 3: 編譯警告

```bash
# 開啟所有警告
gcc -Wall -Wextra -Werror your_code.c
```

### 問題 4: 連結錯誤

```bash
# 檢查函式庫是否存在
ls -l bin/*.a

# 確認符號
nm bin/libList.a | grep list_create

# 連結時指定完整路徑
gcc your_code.c /path/to/libs/List/bin/List.a -o program
```

---

## 進階主題

### 1. 效能優化

```c
// 預先配置容量（Vector）
Vector* vec = vector_create(sizeof(int));
// 如果知道大致大小，可以減少重新配置次數

// 使用合適的資料結構
// 頻繁搜尋 -> HashMap (O(1))
// 有序遍歷 -> RBTree (O(log n))
// 隨機存取 -> Vector (O(1))
```

### 2. 跨平台開發

```c
#ifdef _WIN32
    #include <windows.h>
    // Windows 特定程式碼
#else
    #include <unistd.h>
    // Unix/Linux 特定程式碼
#endif
```

### 3. 自訂記憶體配置器

某些模組支援自訂記憶體配置：
```c
// 可以修改原始碼使用自訂 allocator
void* my_malloc(size_t size) {
    // 自訂配置邏輯
}

void my_free(void* ptr) {
    // 自訂釋放邏輯
}
```

---

## 範例專案

完整的範例專案可以在各模組的 `test/` 或 `src/main.c` 中找到。

建議學習順序：
1. List -> Vector -> Stack -> Queue (基礎線性結構)
2. HashMap -> RBTree (進階結構)
3. String -> File Utilities (實用工具)
4. Socket -> Coroutine (進階主題)
5. Permutation -> Powerset (演算法)
6. BMP (應用)

---

## 參考資源

- **原始碼**: [https://github.com/sunneo/libs](https://github.com/sunneo/libs)
- **授權**: BSD 3-Clause License
- **問題回報**: GitHub Issues
- **貢獻**: Pull Requests 歡迎

---

## 附錄：完整範例程式

### 綜合應用範例：學生管理系統

```c
#include "list.h"
#include "hashmap.h"
#include "cstring.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    int id;
    char name[50];
    double score;
} Student;

int student_compare(const void* a, const void* b) {
    const Student* sa = (const Student*)a;
    const Student* sb = (const Student*)b;
    return (sa->id == sb->id);
}

int int_hash(const void* key) {
    return *(int*)key;
}

int int_equal(const void* a, const void* b) {
    return *(int*)a == *(int*)b;
}

void print_student(void* data) {
    Student* s = (Student*)data;
    printf("ID: %d, Name: %-20s, Score: %.2f\n", s->id, s->name, s->score);
}

int main() {
    // 使用 List 儲存所有學生
    List* students = list_create(sizeof(Student), student_compare);
    
    // 使用 HashMap 快速查詢（ID -> Student*）
    struct HashMap* student_map = hashmap_new(int_hash, int_equal);
    
    // 新增學生
    Student s1 = {1001, "Alice Wang", 95.5};
    Student s2 = {1002, "Bob Chen", 87.3};
    Student s3 = {1003, "Carol Liu", 92.1};
    Student s4 = {1004, "David Lin", 78.9};
    Student s5 = {1005, "Eva Wu", 88.7};
    
    list_push_back(students, &s1);
    list_push_back(students, &s2);
    list_push_back(students, &s3);
    list_push_back(students, &s4);
    list_push_back(students, &s5);
    
    // 建立索引（HashMap）
    ListIter iter = list_get_iter(students);
    while (list_iter_hasNext(iter)) {
        Student* s = (Student*)list_iter_next(iter);
        hashmap_put(student_map, &s->id, s);
    }
    list_iter_delete(iter);
    
    // 顯示所有學生
    printf("All Students:\n");
    printf("----------------------------------------\n");
    list_foreach(students, print_student);
    printf("----------------------------------------\n");
    printf("Total: %u students\n\n", list_size(students));
    
    // 快速查詢特定學生
    int search_id = 1003;
    Student* found = (Student*)hashmap_get(student_map, &search_id);
    if (found) {
        printf("Found student %d:\n", search_id);
        print_student(found);
        printf("\n");
    }
    
    // 計算平均分數
    double total_score = 0.0;
    iter = list_get_iter(students);
    while (list_iter_hasNext(iter)) {
        Student* s = (Student*)list_iter_next(iter);
        total_score += s->score;
    }
    list_iter_delete(iter);
    
    double average = total_score / list_size(students);
    printf("Average score: %.2f\n", average);
    
    // 釋放資源
    hashmap_delete(student_map);
    list_delete(students);
    
    return 0;
}
```

編譯並執行：
```bash
gcc -I./List/include -I./HashMap/include -I./String \
    student_manager.c \
    -L./List/bin -L./HashMap/bin \
    -lList -lHashMap \
    -o student_manager

./student_manager
```

---

**手冊版本**: 1.0  
**最後更新**: 2024-01-18  
**作者**: Sunneo IceCold  
**授權**: BSD 3-Clause License
